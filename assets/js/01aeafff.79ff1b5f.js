"use strict";(self.webpackChunkmynameis=self.webpackChunkmynameis||[]).push([[561],{6218:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>l});var o=t(5893),i=t(1151);const s={slug:"go-dockerfile",title:"Go Dockerfile",authors:["denis"],tags:["software","go"]},a=void 0,r={permalink:"/mynameis/blog/go-dockerfile",source:"@site/blog/07-go-dockerfile/index.mdx",title:"Go Dockerfile",description:"The things I've collected to write my best Dockerfile. Appreciate any comments mentioning I could do it better and more optimal.",date:"2025-01-21T20:11:35.000Z",formattedDate:"January 21, 2025",tags:[{label:"software",permalink:"/mynameis/blog/tags/software"},{label:"go",permalink:"/mynameis/blog/tags/go"}],readingTime:6.63,hasTruncateMarker:!0,authors:[{name:"Denis",title:"Software Experience Dude",key:"denis"}],frontMatter:{slug:"go-dockerfile",title:"Go Dockerfile",authors:["denis"],tags:["software","go"]},unlisted:!1,prevItem:{title:"gopls: how your IDE becomes better every day",permalink:"/mynameis/blog/gopls-08"},nextItem:{title:"Unit test in observability",permalink:"/mynameis/blog/unit-test-observability"}},d={authorsImageUrls:[void 0]},l=[{value:"Preface",id:"preface",level:2},{value:"Base image",id:"base-image",level:2},{value:"Dependencies",id:"dependencies",level:2},{value:"Targets",id:"targets",level:2},{value:"Build prod",id:"build-prod",level:2},{value:"Run prod",id:"run-prod",level:2},{value:"Target dependenciy graph",id:"target-dependenciy-graph",level:2},{value:"A few caveats on debugging remote DAP.",id:"a-few-caveats-on-debugging-remote-dap",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",...(0,i.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"The things I've collected to write my best Dockerfile. Appreciate any comments mentioning I could do it better and more optimal."}),"\n",(0,o.jsx)(n.h2,{id:"preface",children:"Preface"}),"\n",(0,o.jsx)(n.p,{children:"TLDR:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-docker",children:'FROM golang:1.23.1-alpine AS builder\n\nWORKDIR /app\n\nENV CGO_ENABLED=0 \nENV GOOS=linux\n\nCOPY go.mod go.mod\nCOPY go.sum go.sum\nRUN --mount=type=cache,target=/go/pkg/mod/ go mod download -x\n\nCOPY . .\n\nFROM builder AS dev\n\nRUN --mount=type=cache,target=/go/pkg/mod/ --mount=type=cache,target="/root/.cache/go-build" go install github.com/go-delve/delve/cmd/dlv@v1.23.0\n\nRUN --mount=type=cache,target=/go/pkg/mod/ --mount=type=cache,target="/root/.cache/go-build" go build -gcflags=all="-N -l" -o server ./cmd/server\n\nCMD ["dlv", "--listen=:40000", "--continue", "--headless=true", "--api-version=2", "--accept-multiclient", "exec", "server"]\n\nFROM builder AS prod\n\nRUN --mount=type=cache,target=/go/pkg/mod/ --mount=type=cache,target="/root/.cache/go-build" go build -ldflags "-s -w" -o server ./cmd/server\n\nFROM alpine:3.13\n\nRUN addgroup -g 1001 appgroup && adduser -D -G appgroup -u 1001 appuser\n\nWORKDIR /app\n\nUSER 1001\n\nCOPY --from=prod /app/server server\n\nCMD ["/app/server"]\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Link: ",(0,o.jsx)(n.a,{href:"https://github.com/treenq/treenq/blob/98e6d8dd5f5756fe5df561913e10515784ef7163/Dockerfile",children:"https://github.com/treenq/treenq/blob/98e6d8dd5f5756fe5df561913e10515784ef7163/Dockerfile"})]}),"\n",(0,o.jsx)(n.p,{children:"Now let's breakdown what's happening here and why."}),"\n",(0,o.jsxs)(n.admonition,{type:"note",children:[(0,o.jsx)(n.mdxAdmonitionTitle,{}),(0,o.jsxs)(n.p,{children:["I use colima and all the things described here work well. However, all the docs referenses will go to docker. I think they did a great job to push the industry standart. Also you have to turn on buildx to make these features work. It requires buildx installation and setting a feature flag ",(0,o.jsx)(n.code,{children:"DOCKER_BUILDKIT=1"}),"."]})]}),"\n",(0,o.jsx)(n.h2,{id:"base-image",children:"Base image"}),"\n",(0,o.jsx)(n.p,{children:"First, we need a base image in order to build the app. We want the base being less as possible, for that purpose I use alpine:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-docker",children:"FROM golang:1.23.1-alpine AS builder\n"})}),"\n",(0,o.jsxs)(n.p,{children:["You also can consider ",(0,o.jsx)(n.a,{href:"https://github.com/GoogleContainerTools/distroless",children:"distroless"}),", it's very suitable for interpreted languages like python/nodejs, but alpine works well for Go."]}),"\n",(0,o.jsx)(n.h2,{id:"dependencies",children:"Dependencies"}),"\n",(0,o.jsx)(n.p,{children:"The next step we prepare a surface to build the image, all the necessary dependencies we install there."}),"\n",(0,o.jsx)(n.p,{children:"If you need specific timezones, certificates, github private repo creds, the service modules, whatever, we do it right here."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-docker",children:"COPY go.mod go.mod\nCOPY go.sum go.sum\nRUN --mount=type=cache,target=/go/pkg/mod/ go mod download -x\n"})}),"\n",(0,o.jsx)(n.p,{children:"We must copy only desegnated dependencies definition and right after download them.\nIf you don't know why and what is docker layers please refer to Docker basics and get back."}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"-x"})," Flag is kinda adds verbosity showing what ",(0,o.jsx)(n.code,{children:"go mod download"})," executes."]}),"\n",(0,o.jsxs)(n.p,{children:["The interesting details here is ",(0,o.jsx)(n.code,{children:"--mount=type=cache"}),".\nYou can find more in the ",(0,o.jsx)(n.a,{href:"https://docs.docker.com/reference/dockerfile/#run---mounttypecache",children:"reference"})]}),"\n",(0,o.jsxs)(n.p,{children:["If you update a dependency in your ",(0,o.jsx)(n.code,{children:"go.mod"})," and rebuild it, then this statement will not download all the packages from scratch, it creates a designated mount and hold them in one place."]}),"\n",(0,o.jsx)(n.p,{children:"Unfortunately, most of the CI systems create a new image for a new job and it doesn't work in CI, but helps a lot for local testing. For instance, I run e2e tests locally and it saves a couple of minutes every try."}),"\n",(0,o.jsx)(n.p,{children:"And only then we copy the rest of the codebase:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-docker",children:"COPY . .\n"})}),"\n",(0,o.jsxs)(n.admonition,{type:"note",children:[(0,o.jsx)(n.mdxAdmonitionTitle,{}),(0,o.jsx)(n.p,{children:"Don't forget to check your dockerignore to skip copying useless files."})]}),"\n",(0,o.jsx)(n.h2,{id:"targets",children:"Targets"}),"\n",(0,o.jsx)(n.p,{children:"You must have heard about multi-stage images.\nAnd you have built the dockerfiles with 2 stages, first to build a binary and the next to run it in a blank environment."}),"\n",(0,o.jsx)(n.p,{children:"But I will convince you to have 4 stages."}),"\n",(0,o.jsx)(n.p,{children:"Docker has an amazing feature: targets."}),"\n",(0,o.jsx)(n.p,{children:"The targets allow to run a specified stage of the image."}),"\n",(0,o.jsx)(n.p,{children:"Let's have a look how it plays out in case of e2e tests."}),"\n",(0,o.jsx)(n.p,{children:"We have a regular docker compose setup with a database or whatever dependencies you have to run your tests.\nIm a big fan of a debugger and a big hater of infinite print statements. Don't get me wrong, logging is an awesome tool, but not the forgotten prints in a production build."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-docker",children:'FROM builder AS dev\n\nRUN --mount=type=cache,target=/go/pkg/mod/ --mount=type=cache,target="/root/.cache/go-build" go install github.com/go-delve/delve/cmd/dlv@v1.23.0\n\nRUN --mount=type=cache,target=/go/pkg/mod/ --mount=type=cache,target="/root/.cache/go-build" go build -gcflags=all="-N -l" -o server ./cmd/server\n\nCMD ["dlv", "--listen=:40000", "--continue", "--headless=true", "--api-version=2", "--accept-multiclient", "exec", "server"]\n'})}),"\n",(0,o.jsx)(n.p,{children:"On installing delve don't forget to specify cache mount, it has its own dependencies and it will help to speed the build up.\nMoreover, if you don't mount the cache it won't discover the installeed dependencies in a previous step."}),"\n",(0,o.jsxs)(n.p,{children:["The mount flag might look unclear, as an argument you only put a path ",(0,o.jsx)(n.em,{children:"where"})," to mount, you can't control the source of directory, it's managed docker buildkit."]}),"\n",(0,o.jsxs)(n.p,{children:["Then we build a binary with a couple important gcflags, where ",(0,o.jsx)(n.code,{children:"-l"})," disables inlining and ",(0,o.jsx)(n.code,{children:"-N"})," removes optimisations. It matters because otherwise debugger won't be able to show some variables or navigate into some functions.\nYou can read more ",(0,o.jsx)(n.a,{href:"https://pkg.go.dev/cmd/compile",children:"here"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"As the last statement we run dlv."}),"\n",(0,o.jsx)(n.p,{children:"And that's what we have in a docker compose:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"server:\n  build:\n    context: .\n    dockerfile: Dockerfile\n    target: dev\n  ports:\n    - '8000:8000'\n    - '40000:40000'\n  security_opt:\n    - seccomp:unconfined\n  cap_add:\n    - SYS_PTRACE\n"})}),"\n",(0,o.jsx)(n.p,{children:"Here we specify target field, clear and simple. You also can pass it as a cli argument to an image."}),"\n",(0,o.jsx)(n.p,{children:"Ports has 2 elements, a regular app HTTP port and a DAP (Debug Adapter Protocol) port that delve exposes."}),"\n",(0,o.jsxs)(n.p,{children:["Next we add ",(0,o.jsx)(n.code,{children:"secuty_opt"})," since the default Seccomp profile restricts the ",(0,o.jsx)(n.code,{children:"ptrace"})," system call."]}),"\n",(0,o.jsxs)(n.admonition,{type:"note",children:[(0,o.jsx)(n.mdxAdmonitionTitle,{}),(0,o.jsxs)(n.p,{children:["Seccomp is a Linux kernel feature used to restrict the system calls that a process can make. By default, Docker applies a restrictive Seccomp profile to limit potentially dangerous system calls, improving container security. Read more ",(0,o.jsx)(n.a,{href:"https://docs.docker.com/engine/security/seccomp/",children:"here"})," and ",(0,o.jsx)(n.a,{href:"https://docs.docker.com/engine/containers/run/",children:"here"}),"."]})]}),"\n",(0,o.jsxs)(n.p,{children:["When you specify ",(0,o.jsx)(n.code,{children:"seccomp:unconfined"}),", it removes the Seccomp restrictions, allowing the container to make all system calls. This config allows running ",(0,o.jsx)(n.code,{children:"ptrace"})," syscall in the container, delve uses it to set breakpoints, observe memory, etc."]}),"\n",(0,o.jsxs)(n.p,{children:["But it's not enough. We have to not only remove a restriction, but explicitly give a permission, that's why we have ",(0,o.jsx)(n.code,{children:"cap_add"})," statement: to add a capability for that syscall."]}),"\n",(0,o.jsx)(n.h2,{id:"build-prod",children:"Build prod"}),"\n",(0,o.jsx)(n.p,{children:"The prod build is quite simple and well known:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-docker",children:'FROM builder AS prod\n\nRUN --mount=type=cache,target=/go/pkg/mod/ --mount=type=cache,target="/root/.cache/go-build" go build -ldflags "-s -w" -o server ./cmd/server\n'})}),"\n",(0,o.jsxs)(n.p,{children:["We still use mount cache, we just put different build flags, in this case ldflags to achieve exactly the opposite we did in order to build a debug target.\n",(0,o.jsx)(n.code,{children:"-s"})," and ",(0,o.jsx)(n.code,{children:"-w"})," stand for skipping debug info, read more ",(0,o.jsx)(n.a,{href:"https://pkg.go.dev/cmd/link",children:"here"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"run-prod",children:"Run prod"}),"\n",(0,o.jsx)(n.p,{children:"There is no lots of new things for you, I want to focus on a small important thing: a user."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-docker",children:"RUN addgroup -g 1001 appgroup && adduser -D -G appgroup -u 1001 appuser\n\nUSER 1001\n"})}),"\n",(0,o.jsx)(n.p,{children:"There is so many information around on this security topic and I keep seeing zero attention to a user inside the image."}),"\n",(0,o.jsxs)(n.p,{children:["Shortly speaking - less ability less chance to make a mistake or open a vulnerability. Docker has a good blog ",(0,o.jsx)(n.a,{href:"https://www.docker.com/blog/understanding-the-docker-user-instruction/",children:"post"})," to cover why it matters."]}),"\n",(0,o.jsx)(n.h2,{id:"target-dependenciy-graph",children:"Target dependenciy graph"}),"\n",(0,o.jsx)(n.p,{children:"Now about the main concern of so many stages."}),"\n",(0,o.jsx)(n.p,{children:"Why would I build all the stages for releasing my go app?"}),"\n",(0,o.jsxs)(n.p,{children:["You will not, if you turned on buildkit it will behave as a smarter and build only the necessary dependencies, it means it builds the dependency graph and builds only necessary part, so your production CI will never install delve to waste your time.\nThe ",(0,o.jsx)(n.a,{href:"https://docs.docker.com/build/building/multi-stage/#differences-between-legacy-builder-and-buildkit",children:"documentation"})," explains it very well."]}),"\n",(0,o.jsx)(n.h2,{id:"a-few-caveats-on-debugging-remote-dap",children:"A few caveats on debugging remote DAP."}),"\n",(0,o.jsx)(n.p,{children:"If you start a debugging process as is you will find your breakpoints Rejected.\nIt happens because your DAP communicates breakpoints state with DAP server using the client paths, and your client IDE is located on your machine, while the Go binary was built inside an image, another host machine."}),"\n",(0,o.jsxs)(n.p,{children:["You can find the fix in the official ",(0,o.jsx)(n.a,{href:"https://github.com/go-delve/delve/blob/master/Documentation/cli/substitutepath.md",children:"doc"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["First, I would connect to dlv ",(0,o.jsx)(n.code,{children:"dlv connect localhost:40000"})," and test path substitution,\nfor instance ",(0,o.jsx)(n.code,{children:"config substitute-path /path/in/docker /local/path"})," where /path/in/docker is just your WORKDIR statement and /local/path is your local dir (input ",(0,o.jsx)(n.code,{children:"pwd"})," in the project folder).\nAfter that you can try ",(0,o.jsx)(n.code,{children:"list main.main"})," and make sure it lists you a main function without an error."]}),"\n",(0,o.jsx)(n.p,{children:"Eventually I have the following config to configure remote debugger:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-json",children:'{\n      "type": "go",\n      "name": "debug remote service",\n      "mode": "remote",\n      "request": "attach",\n      "port": 40000,\n      "substitutePath": [\n        {\n          "from": "${env:HOME}/projects/project-name",\n          "to": "/app"\n        },\n        {\n          "from": "${env:HOME}/go/pkg/mod/",\n          "to": "/go/pkg/mod/"\n        }\n      ]\n    }\n'})}),"\n",(0,o.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(n.p,{children:"Sorry, have nothing to say. Appreciate if you leave things better than you found it."})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>r,a:()=>a});var o=t(7294);const i={},s=o.createContext(i);function a(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);