"use strict";(self.webpackChunkmynameis=self.webpackChunkmynameis||[]).push([[24],{8554:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>d});var i=n(5893),s=n(1151);const a={slug:"tq-devlog-1",title:"PaaS devlog |#1",authors:["denis"],tags:["paas"]},o=void 0,r={permalink:"/mynameis/blog/tq-devlog-1",source:"@site/blog/07-tq-devlog-1/index.md",title:"PaaS devlog |#1",description:"Devlog #1: github apps, docker builder, cdk8s",date:"2026-01-01T18:27:10.000Z",formattedDate:"January 1, 2026",tags:[{label:"paas",permalink:"/mynameis/blog/tags/paas"}],readingTime:4.325,hasTruncateMarker:!0,authors:[{name:"Denis",title:"Software Experience Dude",key:"denis"}],frontMatter:{slug:"tq-devlog-1",title:"PaaS devlog |#1",authors:["denis"],tags:["paas"]},unlisted:!1,prevItem:{title:"Web in 2026 is a tragedy",permalink:"/mynameis/blog/web-sucks"},nextItem:{title:"How Treenq builds workload images",permalink:"/mynameis/blog/container-in-container-09"}},l={authorsImageUrls:[void 0]},d=[{value:"Devlog #1: github apps, docker builder, cdk8s",id:"devlog-1-github-apps-docker-builder-cdk8s",level:2},{value:"Github apps",id:"github-apps",level:3},{value:"App definition",id:"app-definition",level:3},{value:"Build an image",id:"build-an-image",level:3},{value:"Deploy",id:"deploy",level:3},{value:"Local kube",id:"local-kube",level:3},{value:"Deploy",id:"deploy-1",level:3},{value:"Test",id:"test",level:3}];function c(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h2,{id:"devlog-1-github-apps-docker-builder-cdk8s",children:"Devlog #1: github apps, docker builder, cdk8s"}),"\n",(0,i.jsx)(t.p,{children:"Today I want to share with you my next steps of creating PaaS from scratch.\nOn this page I will cover how I implement a basic deployment flow."}),"\n",(0,i.jsx)(t.p,{children:"The service has the first api call. It's a github webhook, when a merge to main/master comes I spin a container from it."}),"\n",(0,i.jsx)(t.h3,{id:"github-apps",children:"Github apps"}),"\n",(0,i.jsxs)(t.p,{children:["In order to listen users' repository changes it's not necessary to use oauth anymore.\nI can create a ",(0,i.jsx)(t.a,{href:"https://docs.github.com/en/apps/overview",children:"github app"}),", kinda register an app and let my users to install it.\nThis app will let me listen the events the users accepted."]}),"\n",(0,i.jsxs)(t.p,{children:["To make the github webhook secure they provide sha in the headers so I implemented a ",(0,i.jsx)(t.a,{href:"https://github.com/treenq/treenq/blob/main/pkg/crypto/signature.go",children:"verifier"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"app-definition",children:"App definition"}),"\n",(0,i.jsx)(t.p,{children:"Usually users configure an app using a yaml or click buttons.\nWe don't consider terraform for now, it's also viable, but we want a quick solution."}),"\n",(0,i.jsx)(t.p,{children:"I do plan implement a yaml, but now I want to focus on definition as code. I believe it's gonna give me more flexibility and give the users faster access to the app resources such as a database credentials."}),"\n",(0,i.jsxs)(t.p,{children:["So I expected a ",(0,i.jsx)(t.code,{children:"tq"})," module in a go app like this:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-go",children:'package tq\n\nimport (\n\ttqsdk "github.com/treenq/treenq/pkg/sdk"\n)\n\nfunc Build() (tqsdk.Space, error) {\n\treturn tqsdk.Space{\n\t\tKey:    "treenq-poc",\n\t\tRegion: "fra1",\n\t\tService: tqsdk.Service{\n\t\t\tDockerfilePath: "Dockerfile",\n\t\t\tSizeSlug:       "basic-xxs",\n\t\t\tName:           "treenq-poc-service",\n\t\t\tHttpPort:       8000,\n\t\t\tInstanceCount:  1,\n\t\t},\n\t}, nil\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:"Eventually I want to come up with an idea how a user can map this model to the resources, but now I just want to retrieve the config a user defined such a Dockerfile path and the http port to expose."}),"\n",(0,i.jsxs)(t.p,{children:["So I did a builder package to generate a temporary folder, places this config in there, calls that ",(0,i.jsx)(t.code,{children:"Build"})," func and reads the given config as a json output."]}),"\n",(0,i.jsx)(t.h3,{id:"build-an-image",children:"Build an image"}),"\n",(0,i.jsxs)(t.p,{children:["I found an official repo for ",(0,i.jsx)(t.a,{href:"https://github.com/docker/buildx",children:"buildx"}),", it's in Go so I can embed it.\nBut it looks quite a big challenge to solve, it's even scary to imagine the investigation to start using buildx, I would need to:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"run buildx command locally with a buildx debugger"}),"\n",(0,i.jsx)(t.li,{children:"catch the exact function that builds an image"}),"\n",(0,i.jsx)(t.li,{children:"understand all the dependencies and the way to build it"}),"\n",(0,i.jsx)(t.li,{children:"put it into my service and make it work"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["So now Im fine just call ",(0,i.jsx)(t.code,{children:"docker build"})," from CLI.\nI definitely want to get back to buildx, but no clue when."]}),"\n",(0,i.jsx)(t.p,{children:"After tagging the image I need to push it, so I added registry to my docker compose.\nIt couldn't be simpler:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:'registry:\n\timage: registry:2.8.3\n\tports:\n\t\t- "5000:5000"\n'})}),"\n",(0,i.jsx)(t.h3,{id:"deploy",children:"Deploy"}),"\n",(0,i.jsx)(t.p,{children:"Now I can deploy the image. This part is tricky. I couldn't really understand what Im gonna do here."}),"\n",(0,i.jsxs)(t.p,{children:["So I found ",(0,i.jsx)(t.a,{href:"https://cdk8s.io/",children:"cdk8s"}),".\nInitially I defined a testing definition.\nSeems work, even can return me a yaml output.\nUnfortunately, it brings node runtime under the hood, but it pays off now."]}),"\n",(0,i.jsxs)(t.p,{children:["So Im taking the ",(0,i.jsx)(t.code,{children:"tq"})," app definition I showed earlier and create a k8s ",(0,i.jsx)(t.a,{href:"https://github.com/treenq/treenq/blob/6919be57726109ff3f37ce484db3d2457b4cb01e/src/services/cdk/kube.go#L38",children:"definition"})," from it.\nI do a quite simple deployment, a service and an ingress, and return the generated yaml."]}),"\n",(0,i.jsx)(t.p,{children:"Now I have to apply this yaml to the cluster."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Cluster?"})}),"\n",(0,i.jsx)(t.p,{children:"Ok, I have to install a cluster."}),"\n",(0,i.jsx)(t.h3,{id:"local-kube",children:"Local kube"}),"\n",(0,i.jsx)(t.p,{children:"There are plenty of options to choose, but I start caring about the resources I use.\nMy app started with postrgres, then registry, now it has a kube. The main issue I might be able to run a cluster in CI for integration tests, so I want to make my kube instance as small as possible."}),"\n",(0,i.jsx)(t.p,{children:"I found out k3s is the smallest distrubtion. Even though it doesn't follow all the standards, strangers in the internet convinced me I shouldn't ever understand the difference."}),"\n",(0,i.jsxs)(t.p,{children:["So I found an interesting ",(0,i.jsx)(t.a,{href:"https://sachua.github.io/post/Lightweight%20Kubernetes%20Using%20Docker%20Compose.html",children:"guide"})," how to start a cluster locally and it worked well."]}),"\n",(0,i.jsxs)(t.p,{children:["In the progress I needed to add some kubelet ",(0,i.jsx)(t.a,{href:"https://github.com/treenq/treenq/blob/6919be57726109ff3f37ce484db3d2457b4cb01e/docker-compose.yaml#L28",children:"arguments"})," and the flight is done."]}),"\n",(0,i.jsx)(t.h3,{id:"deploy-1",children:"Deploy"}),"\n",(0,i.jsxs)(t.p,{children:["I wish I could use CLI and call ",(0,i.jsx)(t.code,{children:"kubectl apply"}),", but it's not gonna workout.\nThe goal to support a huge amount of clusters, so I accept kubeconfig dynamically as an argument."]}),"\n",(0,i.jsx)(t.p,{children:"The examples to make it I found only using regular rest api that kube provides.\nBut I don't need it, but definitions I have are in yaml."}),"\n",(0,i.jsx)(t.p,{children:"So I found some dynamic client to create resources unsafely.\nSince I expected to not now what resources I create/update it what I need.\nYes, still unsafe, but Im here."}),"\n",(0,i.jsx)(t.p,{children:"Eventually I combine apimachinery and go client together to split the yaml definition by objects, unmarshal them and try creating or updating an object one by one."}),"\n",(0,i.jsx)(t.p,{children:"Later on I want to understand better what I need to create or update, but I would need to implement infra diffs for it, it's not gonna happen soon."}),"\n",(0,i.jsx)(t.h3,{id:"test",children:"Test"}),"\n",(0,i.jsxs)(t.p,{children:["On the testing step I discover my cluster can't pull an image since registry is not a TLS server.\nIt's solved proving a registry config to my cluster.\nSo I add another ",(0,i.jsx)(t.a,{href:"https://github.com/treenq/treenq/blob/6919be57726109ff3f37ce484db3d2457b4cb01e/docker-compose.yaml#L49",children:"volume"})," to my cluster to add the registries config"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:'mirrors:\n  "registry:5000":\n    endpoint:\n      - "http://registry:5000"\n\nconfigs:\n  "registry:5000":\n    tls:\n      insecure_skip_verify: true\n'})})]})}function h(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>r,a:()=>o});var i=n(7294);const s={},a=i.createContext(s);function o(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);