"use strict";(self.webpackChunkmynameis=self.webpackChunkmynameis||[]).push([[862],{3218:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var r=n(5893),s=n(1151);const i={slug:"unit-test-observability",title:"Unit test in observability",authors:["denis"],tags:["software"]},o=void 0,l={permalink:"/mynameis/blog/unit-test-observability",source:"@site/blog/06-unit-test-observability/index.md",title:"Unit test in observability",description:"On this page, I want to cover the caveats I encountered while shaping my approach to unit testing in the context of observability.",date:"2024-10-06T21:43:35.000Z",formattedDate:"October 6, 2024",tags:[{label:"software",permalink:"/mynameis/blog/tags/software"}],readingTime:4.535,hasTruncateMarker:!0,authors:[{name:"Denis",title:"Software Experience Dude",key:"denis"}],frontMatter:{slug:"unit-test-observability",title:"Unit test in observability",authors:["denis"],tags:["software"]},unlisted:!1,prevItem:{title:"Go Dockerfile",permalink:"/mynameis/blog/go-dockerfile"},nextItem:{title:"Web API Design: A Simplified Approach",permalink:"/mynameis/blog/api-design"}},a={authorsImageUrls:[void 0]},c=[{value:"Regular Unit Test",id:"regular-unit-test",level:2},{value:"Side Effects",id:"side-effects",level:2},{value:"Sustainability",id:"sustainability",level:2},{value:"Is It Worth It?",id:"is-it-worth-it",level:2},{value:"A Better Approach",id:"a-better-approach",level:2},{value:"Nop Logger",id:"nop-logger",level:4},{value:"Isolation",id:"isolation",level:4}];function h(e){const t={code:"code",em:"em",h2:"h2",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"On this page, I want to cover the caveats I encountered while shaping my approach to unit testing in the context of observability."}),"\n",(0,r.jsx)(t.p,{children:"It's important to clarify that I\u2019m not referring to testing logs or metrics delivery.\nInstead, I want to focus on testing modules that perform business logic but also include observability calls, like loggers or meters."}),"\n",(0,r.jsx)(t.h2,{id:"regular-unit-test",children:"Regular Unit Test"}),"\n",(0,r.jsx)(t.p,{children:"Let\u2019s start with a typical example of a unit test containing a logger call."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:"func (s *service) Do(ctx context.Context, request model.Object) (model.Response, error) {\n\tres, err := s.repo.Do(ctx, request)\n\tif err != nil {\n\t\treturn res, err\n\t}\n\n\treturn res, nil\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"With a straightforward approach, you'd mock the repository and verify in a unit test that the mock was called with the expected parameters."}),"\n",(0,r.jsx)(t.p,{children:"This is the conventional way of handling things."}),"\n",(0,r.jsx)(t.h2,{id:"side-effects",children:"Side Effects"}),"\n",(0,r.jsx)(t.p,{children:"Now, let\u2019s complicate the example by adding a logger."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:'func (s *service) Do(ctx context.Context, request model.Object) (model.Response, error) {\n  err := s.notImportantRepo.Something(ctx, another.Model(request))\n  if err != nil {\n    s.log.Error("can\'t do something", "err", err.Error())\n  }\n\n\treturn nil\n}\n'})}),"\n",(0,r.jsx)(t.p,{children:"Following the same approach, we can mock both dependencies. Here's how the mock preparation might look:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:'notImportantRepoErr := errors.New("err")\nnotImportantRepo.On("Something", req).Return(notImportantRepoErr)\nlog.On("Error", mock.Anything, "err", notImportantRepoErr.Error())\n'})}),"\n",(0,r.jsx)(t.p,{children:"If we make the logger call more realistic, extracting all the values we need for emergency debugging, we end up with this:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:'s.log.Error("can\'t do something", "err", err.Error(), "ctx", logging.FromContext(ctx), "another", mapper.From(req))\n'})}),"\n",(0,r.jsx)(t.p,{children:"At this point, engineers often use mock.Anything for the logger parameters:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:'log.On("Error", mock.Anything...)\n'})}),"\n",(0,r.jsx)(t.p,{children:"This leads to a couple of issues:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"The logger call becomes a side effect that doesn\u2019t affect the result being tested."}),"\n",(0,r.jsx)(t.li,{children:"Nobody bothers to test what's actually logged."}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"sustainability",children:"Sustainability"}),"\n",(0,r.jsx)(t.p,{children:"Real-world software isn\u2019t always as clean as in theory, raising a few important questions."}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"1."})," Does this approach improve the ",(0,r.jsx)(t.strong,{children:"quality"})," of logging?"]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:'In some ways, yes.\nAt least we confirm that a log message with the correct severity level was sent.\nHowever, ensuring that the necessary parameters are logged requires strict discipline, which isn\u2019t always feasible.\nWe can\u2019t "fix people."'}),"\n",(0,r.jsxs)(t.ol,{start:"2",children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"2."})," Does it ",(0,r.jsx)(t.strong,{children:"reduce PRs"})," focused solely on improving logging?"]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Sadly, no.\nThere's no validation of the parameters being logged, their mapping, formatting, or even the actual log message."}),"\n",(0,r.jsx)(t.p,{children:'Often, only in production do we realize, "Oh, it\'s missing field X." After another debugging round, we might say, "Oh, it\'s missing field Z." This cycle continues.'}),"\n",(0,r.jsxs)(t.ol,{start:"3",children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"3."})," Does it help deliver more ",(0,r.jsx)(t.strong,{children:"observable software"}),"?"]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"This is tricky.\nWhile it might seem like a yes (if we answer question 1), the lack of validation means we\u2019re still prone to errors.\nThe absence of data model testing only slows down software delivery."}),"\n",(0,r.jsx)(t.p,{children:"Every time an engineer touches the function, they might copy a mock from a previous test.\nIf the function behaves differently, they\u2019ll see a failed unit test like this:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:'assert: mock: I don\'t know what to return because the method call was unexpected.\n  Either do Mock.On("Error").Return(...) first, or remove the Error() call.\n  This method was unexpected:\n    Error(params)\n'})}),"\n",(0,r.jsx)(t.p,{children:"Then, they\u2019ll blindly copy the previous mock statement, and the test will pass\u2014despite the logger parameters being completely different."}),"\n",(0,r.jsx)(t.h2,{id:"is-it-worth-it",children:"Is It Worth It?"}),"\n",(0,r.jsx)(t.p,{children:"Here\u2019s my evaluation:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Patching takes more time because of the added mock statements."}),"\n",(0,r.jsx)(t.li,{children:"More CI failures occur due to forgotten mocks."}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"All these costs offer no real benefit.\nWe only confirm that the log was called.\nBut for all we know, we might have sent nil to the logger and won\u2019t realize it until an emergency."}),"\n",(0,r.jsx)(t.h2,{id:"a-better-approach",children:"A Better Approach"}),"\n",(0,r.jsx)(t.p,{children:"There are two paths to improve this situation:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Never allow loggers to accept mock.Anything."}),"\n",(0,r.jsx)(t.li,{children:"Don\u2019t test loggers in the business layer."}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"The first option is ideal but impractical unless you have years to experiment with uncertain payoffs."}),"\n",(0,r.jsx)(t.p,{children:"The second option is more radical but effective: don\u2019t mix observability tests with business logic.\nLet me explain in two steps."}),"\n",(0,r.jsx)(t.h4,{id:"nop-logger",children:"Nop Logger"}),"\n",(0,r.jsx)(t.p,{children:"Start by defining the logger mock as a no-op and remove it from the mocks preparation.\nYou can use one of the following loggers for unit tests:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"An empty value logger"}),"\n",(0,r.jsx)(t.li,{children:"A package-defined nop logger"}),"\n",(0,r.jsx)(t.li,{children:"A mock logger with no assertions"}),"\n",(0,r.jsx)(t.li,{children:"A logger that writes to io.Discard (no impact on unit test output)"}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Any of these options will ignore logger calls and simplify development."}),"\n",(0,r.jsxs)(t.p,{children:["You can apply the same approach to other observability components.\nFor example, ",(0,r.jsx)(t.em,{children:"OpenTelemetry"})," provides ",(0,r.jsx)(t.code,{children:'"go.opentelemetry.io/otel/metric/noop"'})," to create an empty counter or meter."]}),"\n",(0,r.jsx)(t.h4,{id:"isolation",children:"Isolation"}),"\n",(0,r.jsx)(t.p,{children:"Finally, I\u2019m not suggesting we skip logging tests entirely."}),"\n",(0,r.jsxs)(t.p,{children:["We should still test them, but in ",(0,r.jsx)(t.strong,{children:"isolation"})," rather than as a side effect.\nHere\u2019s how:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:'\tfor _, tt := range []testCase{\n\t\t{\n\t\t\tname: "regular log",\n\t\t\thandler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tLoggerFromContext(r.Context()).ErrorContext(r.Context(), "test", "arg1", "text")\n\t\t\t\tw.WriteHeader(200)\n\t\t\t}),\n\t\t\texpectedLogFunc: func(t *testing.T, m map[string]string) {\n\t\t\t\tt.Helper()\n\t\t\t\tassert.Equal(t, "ERROR", m["level"])\n        ...\n\t\t\t},\n\t\t\texpectedStatus: 200,\n\t\t},\n\t} {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tbuf := bytes.NewBuffer(nil)\n\t\t\tl := NewLogger(buf, slog.LevelInfo)\n\t\t\tm := NewLoggingMiddleware(l)\n\t\t\th := m(tt.handler)\n\n\t\t\tw := httptest.NewRecorder()\n\t\t\th.ServeHTTP(w, httptest.NewRequest("POST", "/", nil))\n\n\t\t\tres := buf.String()\n\t\t\tjsonRes := make(map[string]string)\n\t\t\terr := json.Unmarshal([]byte(res), &jsonRes)\n\t\t\trequire.NoError(t, err)\n\n\t\t\ttt.expectedLogFunc(t, jsonRes)\n\n\t\t\tassert.Equal(t, tt.expectedStatus, w.Code)\n\t\t})\n\t}\n'})}),"\n",(0,r.jsx)(t.p,{children:"Instead of writing to stderr/stdout, substitute the logger\u2019s writer with bytes.Buffer, allowing you to capture and validate the exact log message."}),"\n",(0,r.jsx)(t.p,{children:"This way, we\u2019re testing the logger implementation itself, not the side effect of a function that has little to no impact on the application's core functionality."})]})}function d(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>l,a:()=>o});var r=n(7294);const s={},i=r.createContext(s);function o(e){const t=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);